# 4. 数据过期策略

***

# Java面试八股文：Redis数据过期策略深度解析 &#x20;

***

## 1. 概述与定义 &#x20;

**Redis过期策略**是指管理键值对生命周期的机制，确保键在设置的过期时间后被删除，释放内存资源。核心目标是平衡**CPU资源占用**与**内存占用**。 &#x20;

Redis支持以下**四种过期策略**： &#x20;

- **定时删除（定时过期）**：设置定时器主动删除过期键。 &#x20;
- **惰性删除（惰性过期）**：访问键时检查是否过期，过期则删除。 &#x20;
- **定期删除（定期过期）**：周期性随机扫描并删除过期键（默认策略）。 &#x20;
- **异步删除（unlink）**：通过后台线程异步删除键，避免阻塞主线程。 &#x20;

⚠️ **核心问题**： &#x20;

- 如何在频繁访问、高并发场景下高效管理过期键？ &#x20;
- 如何避免内存浪费或CPU过载？ &#x20;

***

## 2. 原理剖析 &#x20;

### 2.1 定时删除（定时过期） &#x20;

**原理**： &#x20;

- **触发机制**：设置键的过期时间时，创建一个定时任务，到期后触发删除。 &#x20;
- **流程图（Mermaid语法）**： &#x20;
  ```mermaid 
  graph TD  
      A[设置键key1过期时间] --> B[创建定时任务]  
      B --> C[到达过期时间]  
      C --> D[触发删除操作]  
  ```


**优缺点**： &#x20;

- **优点**：内存占用低，过期键及时释放。 &#x20;
- **缺点**：定时器数量过多时，CPU开销大，可能导致性能下降。 &#x20;

**现状**：Redis默认未启用，因资源消耗过高。 &#x20;

***

### 2.2 惰性删除（惰性过期） &#x20;

**原理**： &#x20;

- **触发机制**：每次访问键时，调用`expireIfNeeded`函数检查是否过期。 &#x20;
- **流程图（Mermaid语法）**： &#x20;
  ```mermaid 
  sequenceDiagram  
      participant Client  
      participant Redis  

      Client->>Redis: GET key1  
      Redis->>Redis: 调用expireIfNeeded(key1)  
      Redis-->>Client: 返回值或过期提示  
  ```


**关键代码片段**： &#x20;

```java 
// Redis源码片段  
int expireIfNeeded(redisDb *db, robj *key) {  
    if (!keyIsExpired(db, key)) return 0; // 检查是否过期  
    // 删除过期键  
    return dbDelete(db, key);  
}  
```


**优缺点**： &#x20;

- **优点**：CPU资源占用低，仅在访问时处理。 &#x20;
- **缺点**：未访问的过期键长期占用内存，可能导致内存浪费。 &#x20;

***

### 2.3 定期删除（定期过期） &#x20;

**原理**： &#x20;

- **触发机制**： &#x20;
  - 默认每秒执行10次（由`hz`参数控制，默认`hz=10`）。 &#x20;
  - 每次扫描随机选取20个键，删除过期键。 &#x20;
  - 若检测到25%以上过期键，则重复扫描，直到比例低于阈值。 &#x20;
- **流程图（Mermaid语法）**： &#x20;
  ```mermaid 
  graph TD  
      A[触发定期删除任务] --> B[遍历所有DB]  
      B --> C[随机选取20个键]  
      C --> D[检查并删除过期键]  
      D --> E{删除比例>25%？}  
      E -->|是| B  
      E -->|否| F[处理下一个DB]  
  ```


**参数控制**： &#x20;

- `maxmemory`：内存阈值，超过时触发淘汰策略。 &#x20;
- `hz`：定期任务执行频率（默认10次/秒）。 &#x20;

**优缺点**： &#x20;

- **优点**：平衡CPU与内存，避免资源过度消耗。 &#x20;
- **缺点**：可能延迟删除未被访问的过期键。 &#x20;

***

### 2.4 异步删除（unlink） &#x20;

**原理**： &#x20;

- **触发机制**：使用`UNLINK`命令将删除操作移交后台线程处理。 &#x20;
- **流程图（Mermaid语法）**： &#x20;
  ```mermaid 
  sequenceDiagram  
      participant Client  
      participant Redis  
      participant BackgroundThread  

      Client->>Redis: UNLINK key1  
      Redis->>BackgroundThread: 异步处理删除  
      BackgroundThread-->>Redis: 内存释放  
  ```


**优缺点**： &#x20;

- **优点**：避免阻塞主线程，提升高并发场景性能。 &#x20;
- **缺点**：键可能在后台删除前仍被访问到。 &#x20;

***

## 3. 应用目标 &#x20;

- **数据生命周期管理**：自动清理无效数据，避免内存溢出。 &#x20;
- **资源优化**：在CPU、内存、响应速度间取得平衡。 &#x20;
- **场景适配**： &#x20;
  - **高频写入**：定期删除+惰性删除组合使用。 &#x20;
  - **严格时效性**：定时删除（需权衡资源消耗）。 &#x20;

***

## 4. 主要特点对比（表格） &#x20;

| **策略**​ | **触发时机**​      | **CPU占用**​ | **内存占用**​ | **适用场景**​     |
| ------- | -------------- | ---------- | --------- | ------------- |
| 定时删除    | 定时器到期          | 高          | 低         | 对时效要求极高（如金融）  |
| 惰性删除    | 键被访问时          | 低          | 高         | CPU资源紧张，内存较充裕 |
| 定期删除    | 周期性扫描（默认1秒）    | 中          | 中         | 平衡场景（默认策略）    |
| 异步删除    | 手动调用\`UNLINK\` | 低（异步）      | 中         | 高并发需避免阻塞      |

***

## 5. 主要内容及其组成部分 &#x20;

### 5.1 定时删除的实现细节 &#x20;

- **过期字典（expires dict）**：存储所有键的过期时间。 &#x20;
- **定时器（时间轮）**：通过`aeCreateTimeEvent`注册定时任务。 &#x20;
- **缺点示例**： &#x20;
  ```text 
  // 假设设置1000个键，每个1秒后过期  
  // 定时器触发时可能引发CPU过载，导致其他操作延迟。  
  ```


***

### 5.2 惰性删除的边界场景 &#x20;

- **极端情况**： &#x20;
  ```text 
  // 键key1设置1天后过期，但从未被访问  
  // 1天后内存仍占用，直到被定期删除扫描到。  
  ```

- **优化方案**：结合定期删除，定期清理未访问键。 &#x20;

***

### 5.3 定期删除的参数调优 &#x20;

- **关键配置参数**： &#x20;
  ```text 
  # redis.conf配置示例  
  hz 10             // 每(1000ms / 10 = 100ms)秒执行1次定期任务  
  maxmemory 1g      // 内存阈值  
  ```

- **性能权衡**： &#x20;
  - 提高`hz`值可加快过期键清理，但增加CPU消耗。 &#x20;
  - 降低`hz`值减少CPU占用，但可能增加内存占用。 &#x20;

***

### 5.4 异步删除与`UNLINK`命令 &#x20;

- **语法示例**： &#x20;
  ```text 
  UNLINK key1 key2 key3 // 异步删除多个键  
  ```

- **与**\*\*`DEL`\*\***对比**： &#x20;
  - `DEL`：同步删除，阻塞主线程。 &#x20;
  - `UNLINK`：异步删除，立即返回成功，后台释放内存。 &#x20;

***

## 6. 应用与拓展 &#x20;

### 6.1 电商秒杀场景 &#x20;

- **问题**：短时高并发写入大量过期键（如临时库存）。 &#x20;
- **方案**： &#x20;
  - **定期删除+惰性删除**：默认策略可高效清理过期键。 &#x20;
  - **异步删除**：对关键键使用`UNLINK`避免阻塞。 &#x20;

***

### 6.2 内存淘汰与过期策略的协同 &#x20;

- **内存淘汰策略（****`maxmemory-policy`****）**： &#x20;
  | 策略名称         | 描述             |
  | ------------ | -------------- |
  | volatile-lru | 从过期键中淘汰最近最少使用的 |
  | allkeys-lfu  | 从所有键中淘汰使用频率最低的 |
  | noeviction   | 达到内存上限后拒绝写操作   |
- **示例配置**： &#x20;
  ```text 
  maxmemory-policy allkeys-lru // 内存满时淘汰未过期键  
  ```


***

### 6.3 近似LRU算法实现 &#x20;

- **Redis近似LRU**： &#x20;
  - 为每个键记录访问时间戳（24位），随机采样后淘汰最小值。 &#x20;
  - **优势**：空间开销小（仅24位/键），性能接近精确LRU。 &#x20;
- **代码片段（伪代码）**： &#x20;
  ```java 
  // 采样20个键，选择最近最少访问的  
  for (int i = 0; i < 20; i++) {  
      key = randomKey();  
      if (key.lastAccessTime < minTime) {  
          minKey = key;  
      }  
  }  
  delete(minKey);  
  ```


***

## 7. 面试问答（模拟回答） &#x20;

### Q1：Redis的过期策略有哪些？如何选择？ &#x20;

**回答**： &#x20;

Redis的过期策略包括： &#x20;

1. **定时删除**：通过定时器触发，及时释放内存，但CPU开销大。 &#x20;
2. **惰性删除**：访问时检查，CPU友好但可能浪费内存。 &#x20;
3. **定期删除**：周期性扫描，平衡CPU与内存（默认策略）。 &#x20;
4. **异步删除**：通过`UNLINK`命令异步删除，避免阻塞。 &#x20;

**选择依据**： &#x20;

- **高并发写入**：定期删除+惰性删除组合。 &#x20;
- **严格时效性**：定时删除（需注意资源消耗）。 &#x20;
- **避免阻塞**：关键操作使用`UNLINK`。 &#x20;

***

### Q2：定期删除如何避免扫描过载？ &#x20;

**回答**： &#x20;

定期删除通过以下机制控制扫描范围： &#x20;

1. **分库扫描**：遍历所有数据库（DB），逐个处理。 &#x20;
2. **随机采样**：每次从每个DB中随机选取20个键检查。 &#x20;
3. **自适应调整**： &#x20;
   - 若检测到25%以上过期键，重复扫描直到比例下降。 &#x20;
   - 限制单次扫描时间（如默认每秒最多25ms）。 &#x20;

**示例配置**： &#x20;

```text 
hz 10 // 每秒10次扫描，避免单次过载。  (1000ms / 10 = 100ms)
```


***

### Q3：为什么Redis默认不使用定时删除？ &#x20;

**回答**： &#x20;

定时删除的缺点包括： &#x20;

1. **CPU资源消耗大**：每个过期键需独立定时器，高并发下可能引发性能问题。 &#x20;
2. **内存占用问题**：定时器数量过多可能导致内存泄漏。 &#x20;
3. **维护成本高**：需管理大量定时任务，增加系统复杂性。 &#x20;

因此，默认采用**定期删除+惰性删除**的组合策略，平衡资源与效率。 &#x20;

***

### Q4：过期键未被访问时如何清理？ &#x20;

**回答**： &#x20;

通过**定期删除**机制： &#x20;

1. Redis每隔`hz`周期（默认100ms）触发一次扫描。 &#x20;
2. 随机选取部分键检查，删除过期键。 &#x20;
3. 若过期键比例高，则延长扫描时间，直到清理足够数量。 &#x20;

**示例**： &#x20;

```text 
// 假设某键过期但未被访问，定期删除会在扫描时清理它。  
```


***

### Q5：`UNLINK`与`DEL`的区别是什么？ &#x20;

**回答**： &#x20;

| **特性**​   | **UNLINK**​ | **DEL**​    |
| --------- | ----------- | ----------- |
| **执行方式**​ | 异步删除（后台线程）  | 同步删除（阻塞主线程） |
| **返回结果**​ | 立即返回成功      | 等待删除完成再返回   |
| **适用场景**​ | 高并发场景避免阻塞   | 低并发或非关键操作   |

```text 
// 高并发场景推荐  
UNLINK key1 // 不阻塞后续操作  
```


***

## 总结 &#x20;

Redis过期策略是面试高频考点，需深入理解定时、惰性、定期、异步四种机制的原理与场景适配。结合内存淘汰策略（如LRU/LFU）和实际案例（如秒杀场景），能够全面展示技术深度与工程思维！ 🚀
