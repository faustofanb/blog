# 第五章. 消息中间件

[一. RabbitMQ](<一. RabbitMQ/一. RabbitMQ.md> "一. RabbitMQ")

[二. RocketMQ](<二. RocketMQ/二. RocketMQ.md> "二. RocketMQ")

# A. 消息不丢失

## 生产者发布确认

发布确认机制是一种轻量级的确认机制，确保消息从生产者到 RabbitMQ 服务器的传递是可靠的。生产者在发布消息时可以请求服务器的确认，服务器会在将消息持久化后发送确认给生产者。如果生产者在设定的时间内未收到确认，则可以认为消息传递失败并进行重试。这种机制极大地提高了消息传递的可靠性&#x20;

## 持久化队列和消息

RabbitMQ 提供了持久化功能来确保消息在系统重启后依然存在。持久化队列是一种特殊的队列配置，使得队列在 RabbitMQ 服务器重启后不会丢失。持久化消息是指将消息标记为持久化，这样即使 RabbitMQ 服务器重启，这些消息也会被存储在磁盘上而不会丢失。&#x20;

## 消费者确认

RabbitMQ 使用消息确认机制来确保消息从队列到消费者的传递过程中的可靠性。当消费者接收到消息后，会向 RabbitMQ 发送一个确认，表明消息已经成功处理。如果 RabbitMQ 没有收到确认，那么该消息会被重新放回队列并投递给其他消费者。这种机制防止了消息在消费者处理过程中因故障而丢失。&#x20;

# B. 消息重复消费

## 消息去重

a. 消息唯一标识（Message Deduplication ID）

每条消息都可以包含一个唯一标识符（例如 UUID）。消费者在处理消息时，可以检查该标识符是否已经处理过。如果已经处理过，则忽略该消息。为了实现这一点，消费者通常会维护一个已处理消息的记录，例如使用数据库或缓存（如 Redis）来存储这些唯一标识符。 &#x20;

b. 幂等性

确保消息处理操作是幂等的，即同一条消息被处理多次不会对系统状态造成影响。例如，如果一条消息的处理结果是更新数据库中的某个记录，那么可以使用唯一标识符来确保更新操作仅执行一次。

## 分布式锁

&#x20;在某些情况下，可以使用分布式锁来确保同一条消息不会被多个消费者同时处理。分布式锁通常使用诸如 Zookeeper、Redis 或 Consul 等工具来实现。&#x20;

# C. 消息堆积

## 增加消费者

当消息堆积时，最直接的方法是增加消费者数量，以提高消息的处理速度。这可以通过以下几种方式实现： &#x20;

- **增加实例数量**：在微服务架构中，可以增加消费者服务实例的数量，以并行处理更多消息。
- **水平扩展**：如果消费者是部署在集群中的，可以通过增加集群节点数量来扩展处理能力。

## 提高消费者消费能力

提高消费者的处理性能可以有效减少消息堆积。可以从以下几个方面进行优化： &#x20;

- **提高处理效率**：优化消息处理逻辑，使其更高效。例如，减少复杂计算或 I/O 操作。
- **批量处理**：将多条消息合并为一个批次进行处理，可以减少处理开销和网络传输时间。
- **异步处理**：使用异步处理模式，减少每条消息处理的阻塞时间。

## 扩大队列容积

可以使用惰性队列:

1. 接收到消息后, 直接存入磁盘.
2. 消费者消费消息时才会从磁盘中读取并加载到内存.
3. 支持数百万条消息存储.

# D. 延迟队列

## TTL和死信队列

这是在 RabbitMQ 中实现延迟队列的常用方法，利用消息的 TTL（Time-To-Live）和死信交换器来实现延迟传递。以下是实现步骤： &#x20;

a. 配置 TTL 队列

首先，创建一个带有 TTL 属性的队列。TTL 指定了消息在队列中存活的时间，超过这个时间后，消息将被转移到死信交换器。 &#x20;

b. 配置死信交换器（DLX）

创建一个死信交换器和对应的队列，当消息在 TTL 队列中过期后，消息将被转移到这个死信队列。 &#x20;

c. 消息处理流程

1. 生产者将消息发送到 TTL 队列。
2. 消息在 TTL 队列中等待指定时间，之后过期。
3. 过期消息被转移到死信交换器，并路由到指定的死信队列。
4. 消费者从死信队列中接收并处理消息。

这种方法的优点是简单易行，不需要额外的插件，但存在消息延迟精度不高和对大量消息处理性能有限的缺点。

## 延迟消息插件

RabbitMQ 提供了一个名为 rabbitmq\_delayed\_message\_exchange 的插件，可以直接支持延迟消息。以下是使用该插件的步骤： &#x20;

a. 安装插件

1. 下载并安装 rabbitmq\_delayed\_message\_exchange 插件。
2. 在 RabbitMQ 配置文件中启用该插件。

b. 配置延迟交换器

创建一个延迟交换器，指定类型为 x-delayed-message，并配置路由键和延迟时间。 &#x20;

c. 消息处理流程

1. 生产者将消息发送到延迟交换器，并设置延迟时间。
2. 延迟交换器在消息延迟时间到期后，将消息路由到指定队列。
3. 消费者从队列中接收并处理消息。

这种方法的优点是使用简单，延迟精度高，且对大量消息处理性能较好。

## 自定义实现

对于一些特殊需求，可以自定义实现延迟队列。以下是一个常见的自定义实现方式： &#x20;

a. 定时任务调度

使用定时任务调度系统（如 Quartz、Cron 等）结合数据库或缓存（如 Redis）来实现消息延迟。 &#x20;

b. 定时轮询

将消息存储在数据库或缓存中，并使用定时轮询任务检查并处理到期消息。 &#x20;

这种方法的优点是灵活性高，可以满足复杂的延迟需求，但实现复杂度和维护成本较高。

# E. 高可用机制

## 普通集群

1. 会在集群的各个节点间共享部分数据, 包括: 交换机, 队列元信息. 不包含队列中的消息.
2. 当访问集群某节点时, 如果队列不在该节点, 会从数据所在节点传递到当前节点并返回.
3. 队列所在节点宕机, 队列中的消息就会丢失.

## 镜像集群

1. 交换机, 队列, 队列中的消息会在各个MQ的镜像节点中同同步备份.
2. 创建队列的节点被称为该队列的主节点, 备份到的其他节点叫做该队列的镜像节点.
3. 一个队列的主节点可能是另一个队列的镜像节点.
4. 所有操作都是主节点完成, 然后同步给镜像节点.
5. 主节点宕机后, 镜像节点会成为新的主节点.

## 仲裁队列

在分布式系统中，仲裁队列（Quorum Queues）是RabbitMQ 3.8版本引入的一种新的高可用队列类型，用于替代传统的镜像队列（Mirrored Queues）。仲裁队列设计用于在集群环境中提供更高的可靠性和一致性。以下是关于仲裁队列的详细解释： &#x20;

#### 仲裁队列的特点 &#x20;

1. **一致性和可用性** 仲裁队列使用 Raft 共识算法，确保在多个节点之间的一致性。这意味着在发生网络分区或节点故障时，仲裁队列能够保持数据一致性，并尽可能高地保持可用性。 &#x20;
2. **持久性** 仲裁队列中的消息和元数据都会被持久化到磁盘上，这确保了即使在集群中的所有节点都重启后，消息也不会丢失。 &#x20;
3. **自动恢复** 当节点故障时，仲裁队列能够自动从剩余的健康节点中恢复，保持队列的高可用性。 &#x20;
4. **动态成员调整** 仲裁队列支持动态调整队列成员的数量，允许在运行时增加或减少参与投票的节点数量。 &#x20;

#### 使用仲裁队列的好处 &#x20;

1. **高可靠性** 通过使用 Raft 算法，仲裁队列能够在发生故障时确保数据的一致性和持久性，提高了系统的可靠性。 &#x20;
2. **简化运维** 与传统的镜像队列相比，仲裁队列的配置和管理更加简单，不需要手动配置每个队列的镜像策略。 &#x20;
3. **更好的性能** 仲裁队列在设计上针对高负载场景进行了优化，能够更高效地处理大量消息，减少延迟。
