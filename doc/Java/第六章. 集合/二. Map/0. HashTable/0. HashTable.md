# 0. HashTable

在 Java 集合框架中，**哈希表（Hash Table）** 是一种基于哈希（Hash）原理实现的数据结构，主要用于高效地存储和查找数据。Java 中的 `HashMap` 和 `HashSet` 是哈希表的典型实现，它们通过哈希函数将键或元素映射到数组中的位置，从而实现快速的增删改查操作。以下是 Java 集合中哈希表的核心知识点总结：

***

### **1. 哈希表的基本概念**

#### **1.1 定义**

- **哈希表（Hash Table）**：一种通过哈希函数将键（Key）或元素映射到数组位置的数据结构，实现快速的查找、插入和删除操作。
- **哈希函数（Hash Function）**：将任意数据（如字符串、对象）映射为一个整数（哈希值），用于确定数据在数组中的存储位置。
- **哈希冲突（Collision）**：不同的键或元素经过哈希函数计算后得到相同的哈希值，导致冲突。

#### **1.2 核心特点**

| 特性          | 说明                                      |
| ----------- | --------------------------------------- |
| **无序性**​    | 元素的存储顺序与插入顺序无关。                         |
| **不重复性**​   | 基于键或元素的哈希值和 \`equals()\` 方法判断是否重复。      |
| **高效操作**​   | 平均时间复杂度为 \*\*O(1)\*\*（理想情况下，无冲突或冲突较少时）。 |
| **依赖哈希函数**​ | 哈希函数的设计直接影响性能（如冲突率、分布均匀性）。              |

***

### **2. Java 中的哈希表实现**

#### \*\*2.1 \*\***`HashMap`**

- **作用**：存储 **键值对（Key-Value）**，通过键快速查找值。
- **底层实现**：
  - **JDK 1.8 及以后**：基于 **数组 + 链表 + 红黑树** 结构。
    - **数组（Table）**：存储数据的主结构，初始容量为 16，容量总是 2 的幂次。
    - **链表/红黑树**：当数组位置（桶）的链表长度超过阈值（默认 8）时，链表转为红黑树，降低查找时间复杂度。
  - **哈希冲突解决**：
    - **链地址法**：同一哈希值的元素存储在链表中。
    - **红黑树优化**：当链表长度 > 8 时，转为红黑树（时间复杂度降为 O(logN)）。
- **核心方法**：
  - `put(K key, V value)`：插入键值对。
  - `get(K key)`：通过键获取值。
  - `remove(K key)`：删除键值对。

#### \*\*2.2 \*\***`HashSet`**

- **作用**：存储 **唯一元素**，不允许重复。
- **底层实现**：基于 `HashMap` 实现，元素作为 `HashMap` 的键，值固定为 `PRESENT`（一个静态常量）。
- **特点**：
  - 元素唯一性依赖 `HashMap` 的键唯一性。
  - 无序，不可重复。
- **核心方法**：
  - `add(E element)`：添加元素。
  - `contains(E element)`：判断元素是否存在。
  - `remove(E element)`：删除元素。

***

### **3. 哈希表的核心原理**

#### **3.1 哈希函数与哈希值**

- **哈希值计算**：
  - 对象的 `hashCode()` 方法返回其哈希值（`int` 类型）。
  - 字符串的 `hashCode()` 通过字符的 ASCII 值计算（如 `"abc"` 的哈希值为 `96354`）。
- **冲突处理**：
  - **相同哈希值**：通过 `equals()` 方法判断是否为同一元素/键。
  - **不同对象，相同哈希值**：存储在同一个桶（Bucket）中，通过链表或红黑树解决冲突。

#### **3.2 存储与查找流程**

1. **插入元素**：
   - 计算元素的哈希值（`hashCode()`）。
   - 通过哈希值和数组长度计算索引（`index = (hash & 0x7FFFFFFF) % array.length`）。
   - 若该位置为空，直接存储；否则，遍历链表/红黑树，通过 `equals()` 判断是否已存在。
2. **查找元素**：
   - 计算目标元素的哈希值，定位到数组索引。
   - 在链表/红黑树中遍历，通过 `equals()` 匹配元素。

***

### **4. 关键代码示例**

#### **4.1 ****`HashMap`**** 的简单使用**

```java 
HashMap<String, Integer> map = new HashMap<>();
map.put("Alice", 25);  // 插入键值对
map.put("Bob", 30);
System.out.println(map.get("Alice"));  // 输出 25
map.remove("Bob");  // 删除键值对
```


#### **4.2 ****`HashSet`**** 的简单使用**

```java 
HashSet<String> set = new HashSet<>();
set.add("apple");
set.add("banana");
System.out.println(set.contains("apple"));  // 输出 true
set.remove("banana");  // 删除元素
```


***

### **5. 核心特性与注意事项**

#### **5.1 特性**

- **高效性**：平均 O(1) 时间复杂度（理想情况下）。
- **动态扩容**：
  - 当元素数量超过阈值（容量 × 负载因子，默认负载因子 0.75）时，数组扩容为原来的 2 倍。
  - 扩容时需要重新计算元素的哈希值和位置（称为 **Rehash**）。
- **线程不安全**：`HashMap` 和 `HashSet` 在多线程环境下可能产生问题，需使用 `ConcurrentHashMap` 替代。

#### **5.2 注意事项**

1. **自定义对象作为键或元素**：
   - 必须重写 `hashCode()` 和 `equals()` 方法，确保逻辑一致：
     ```java 
     @Override
     public int hashCode() { ... }
     @Override
     public boolean equals(Object obj) { ... }
     ```

   - 示例：若自定义 `Person` 类作为键，需根据唯一属性（如 `id`）计算哈希值。
2. **哈希冲突的影响**：
   - 频繁冲突会导致链表过长，降低性能（极端情况下退化为 O(n)）。
   - 解决方案：合理设计哈希函数，使哈希值分布均匀。
3. **初始容量与负载因子**：
   - 初始化时指定合适的容量（避免频繁扩容）。
   - 负载因子（`loadFactor`）控制扩容阈值，需权衡空间与性能。

***

### **6. 哈希表的应用场景**

1. **快速查找**：如缓存系统、数据库索引。
2. **去重**：如统计唯一用户、去重日志。
3. **关联存储**：如用户信息映射（用户名 → 用户对象）。
4. **集合操作**：如 `HashSet` 的并集、交集运算（通过 `retainAll()`、`addAll()` 等方法）。

***

### **7. 总结**

Java 中的哈希表（`HashMap` 和 `HashSet`）通过哈希函数和数组结合，实现了高效的数据操作。其核心原理是：

- **哈希函数**：将键或元素映射到数组位置。
- **冲突解决**：通过链表或红黑树处理冲突。
- **动态扩容**：保证性能稳定。

掌握哈希表的实现原理和使用技巧，可以显著提升程序的性能和代码质量。如需进一步了解底层源码或性能优化细节，可结合知识库中的 `HashMap` 和 `HashSet` 实现深入分析。
