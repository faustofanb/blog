# 1. 核心属性

# Java面试八股文：HashMap深度解析（结构清晰，含示例与图表）

***

## 1. 概述与定义 &#x20;

**HashMap** 是 Java 集合框架中 `Map` 接口的实现类，用于存储**键值对（Key-Value）**。它基于哈希表（Hash Table）实现，通过哈希函数（Hash Function）将键映射到数组的索引位置，结合链表和红黑树解决哈希冲突。 &#x20;

**核心特性**： &#x20;

- **非线程安全**：多线程环境下需使用 `ConcurrentHashMap`。 &#x20;
- **允许 ****`null`**** 键或值**：仅允许一个 `null` 键，但多个 `null` 值。 &#x20;
- **无序性**：元素存储顺序与插入顺序无关。 &#x20;

***

## 2. 主要特点 &#x20;

### 2.1 数据结构 &#x20;

采用 **数组 + 链表 + 红黑树** 的混合结构： &#x20;

- **数组（Node\[] table）**：存储桶（Bucket），初始容量为 `16`，扩容时按 **2 倍增长**。 &#x20;
- **链表（Linked List）**：解决哈希冲突（Hash Collision）。 &#x20;
- **红黑树（JDK 8+）**：当链表长度超过 `8` 时，转换为红黑树以优化查询效率（时间复杂度从 `O(n)` 降为 `O(log n)`）。 &#x20;

### 2.2 性能 &#x20;

- **时间复杂度**： &#x20;
  - `put` 和 `get` 平均时间复杂度为 **O(1)**，最坏情况为 **O(n)**（哈希冲突严重时）。 &#x20;
  - 红黑树优化后，最坏情况降为 **O(log n)**。 &#x20;
- **空间复杂度**：与元素数量和哈希表容量相关。 &#x20;

***

## 3. 应用目标 &#x20;

- **高效存储与检索**：通过键快速定位值。 &#x20;
- **动态扩容**：根据负载因子（Load Factor，默认 `0.75`）自动扩容。 &#x20;
- **灵活键值对管理**：支持键值对的增删改查。 &#x20;

***

## 4. 主要内容及其组成部分 &#x20;

### 4.1 核心属性 &#x20;

| 属性名            | 类型                | 作用描述                                                                       |
| -------------- | ----------------- | -------------------------------------------------------------------------- |
| \`table\`      | \`Node\<K,V>\[]\` | 哈希表的数组结构，存储所有键值对。                                                          |
| \`size\`       | \`int\`           | 当前存储的键值对数量。                                                                |
| \`threshold\`  | \`int\`           | 扩容阈值，当 \`size > threshold\` 时触发扩容（\`threshold = capacity \* loadFactor\`）。 |
| \`loadFactor\` | \`float\`         | 负载因子，控制扩容触发时机，默认 \`0.75\`。                                                 |
| \`modCount\`   | \`int\`           | 记录结构修改次数，用于迭代时的并发修改检测。                                                     |

### 4.2 构造方法 &#x20;

```java 
// 默认构造方法：容量 16，负载因子 0.75
HashMap() { this.loadFactor = DEFAULT_LOAD_FACTOR; }

// 指定初始容量和负载因子
HashMap(int initialCapacity, float loadFactor) { 
    if (initialCapacity < 0) throw new IllegalArgumentException();
    this.loadFactor = loadFactor;
}
```


### 4.3 核心方法 &#x20;

#### 4.3.1 `put(K key, V value)` &#x20;

**流程**： &#x20;

1. **计算哈希值**：通过 `hash(key.hashCode())` 优化哈希分布。 &#x20;
2. **定位索引**：`index = hash & (table.length - 1)`。 &#x20;
3. **链表/红黑树操作**： &#x20;
   - 若桶为空，直接插入。 &#x20;
   - 若存在冲突，遍历链表或红黑树查找相同键。 &#x20;
   - 若找到相同键，更新值；否则插入新节点。 &#x20;
4. **结构转换**：当链表长度超过 `8` 时，转为红黑树。 &#x20;
5. **扩容检查**：若 `size > threshold`，触发扩容。 &#x20;

#### 4.3.2 `get(Object key)` &#x20;

**流程**： &#x20;

1. 计算键的哈希值。 &#x20;
2. 定位桶的索引。 &#x20;
3. 遍历链表或红黑树，通过 `key.equals()` 查找匹配项。 &#x20;

***

## 5. 原理剖析 &#x20;

### 5.1 哈希函数优化 &#x20;

JDK 8 引入了 `hash()` 方法优化哈希分布： &#x20;

```java 
static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
```


- **作用**：通过高位异或降低哈希冲突概率。 &#x20;
- **示例**：若 `hashCode()` 返回 `0x12345678`，则 `h >>> 16 = 0x00005678`，最终哈希值为 `0x12345678 ^ 0x00005678 = 0x12340000`。 &#x20;

### 5.2 扩容机制（Rehash） &#x20;

**触发条件**：`size > threshold`。 &#x20;

**流程**： &#x20;

1. **扩容为原容量的 2 倍**。 &#x20;
2. **重新计算所有元素的索引**（因数组长度变化）。 &#x20;
3. **迁移元素到新数组**： &#x20;
   - 遍历旧数组，逐个元素重新哈希到新位置。 &#x20;
   - 链表遍历过程中，**拆分链表**（JDK 8 优化：通过 `next` 指针拆分，减少遍历次数）。 &#x20;

**Mermaid 图表示例**： &#x20;

```mermaid 
graph LR
    A[扩容触发] --> B[新容量=原容量×2]
    B --> C[重新计算索引]
    C --> D[迁移元素到新数组]
    D --> E[完成扩容]
```


### 5.3 红黑树转换条件 &#x20;

- **转换条件**：链表长度 > 8 且数组长度足够大（JDK 8 需 `table.length >= 64`）。 &#x20;
- **降级条件**：红黑树节点数 <= 6 时转回链表。 &#x20;

***

## 6. 应用与拓展 &#x20;

### 6.1 典型应用场景 &#x20;

- **缓存系统**：如 LRU 缓存，通过键快速访问值。 &#x20;
- **配置管理**：存储配置信息（如 `key=config_name, value=config_value`）。 &#x20;

### 6.2 替代方案对比 &#x20;

| 类型                    | 线程安全 | 允许 \`null\` | 有序性  |
| --------------------- | ---- | ----------- | ---- |
| \`HashMap\`           | 否    | 是           | 无    |
| \`Hashtable\`         | 是    | 否           | 无    |
| \`ConcurrentHashMap\` | 是    | 是（仅一个键）     | 无    |
| \`TreeMap\`           | 否    | 否           | 按键排序 |

### 6.3 常见问题处理 &#x20;

- **`null`**\*\* 键的处理\*\*：`null` 键存储在 `table[0]` 位置。 &#x20;
- **哈希冲突**：通过链表或红黑树解决。 &#x20;
- **扩容性能问题**：JDK 8 通过“分段迁移”优化，减少停顿时间。 &#x20;

***

## 7. 面试问答 &#x20;

### 问题 1：HashMap 的实现原理是什么？ &#x20;

**回答**： &#x20;

HashMap 基于哈希表实现，数据结构为 **数组 + 链表 + 红黑树**。键通过 `hash()` 方法计算索引，若冲突则形成链表。当链表长度超过 8 且数组长度 ≥64 时，转为红黑树以提升查询效率。扩容时，容量按 2 倍增长，所有元素重新哈希到新数组。 &#x20;

### 问题 2：HashMap 的扩容机制如何触发？ &#x20;

**回答**： &#x20;

当键值对数量超过 **阈值（threshold = capacity × loadFactor）** 时触发扩容。例如，默认容量 16，负载因子 0.75，阈值为 12。当 `size > 12` 时，扩容为 32，并重新计算所有元素的索引。 &#x20;

### 问题 3：为什么 HashMap 要用红黑树？ &#x20;

**回答**： &#x20;

红黑树是平衡二叉树，查询时间复杂度为 **O(log n)**，而链表为 **O(n)**。当链表过长时，红黑树能显著提升查询效率。例如，当链表长度超过 8 时自动转换，避免极端情况下的性能下降。 &#x20;

### 问题 4：HashMap 是线程安全吗？如何保证线程安全？ &#x20;

**回答**： &#x20;

- **非线程安全**：多个线程写入可能导致死循环或数据不一致。 &#x20;
- **解决方案**： &#x20;
  1. 使用 `ConcurrentHashMap`（分段锁优化）。 &#x20;
  2. 外部加锁（如 `Collections.synchronizedMap()`）。 &#x20;

### 问题 5：HashMap 和 Hashtable 的区别是什么？ &#x20;

**回答**： &#x20;

| 特性                      | HashMap                       | Hashtable                |
| ----------------------- | ----------------------------- | ------------------------ |
| **线程安全**​               | 否                             | 是                        |
| **`null`** \*\* 键值\*\*​ | 允许一个 \`null\` 键，多个 \`null\` 值 | 不允许 \`null\` 键或值         |
| **继承关系**​               | 实现 \`Map\` 接口                 | 继承 \`Dictionary\` 类（已过时） |
| **扩容机制**​               | JDK 8 引入红黑树优化                 | 仅用链表，性能较差                |

***

## 总结 &#x20;

HashMap 是 Java 中最常用的键值对容器，其核心在于哈希表与链表/红黑树的结合。掌握其源码细节（如哈希函数、扩容机制、红黑树转换）和线程安全问题，是应对面试和实际开发的关键。通过结合示例与图表，可以更直观地理解其设计思想与实现原理。
