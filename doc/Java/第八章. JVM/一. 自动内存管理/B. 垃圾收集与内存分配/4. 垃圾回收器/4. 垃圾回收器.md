# 4. 垃圾回收器

***

## 1. 概述与定义

垃圾回收器（Garbage Collector, GC）是 JVM 自动内存管理的核心组件之一，其主要任务是自动识别和回收不再使用的对象，从而释放内存资源，避免内存泄露和内存溢出。垃圾回收器在 JVM 内部分为多种类型，每种回收器都采用不同的算法和策略，根据应用场景的不同，能够在保证系统吞吐量和响应时间的同时，最大限度地提高内存利用率。 &#x20;

在 JVM 中，垃圾收集主要遵循“分代收集”策略，即将堆内存划分为年轻代、老年代（以及 JDK8 之前的永久代或 JDK8 以后的元空间），并对每一代采用不同的回收算法。垃圾回收器就是根据内存使用情况和 GC 策略，在合适的时机启动垃圾回收过程，从而自动回收无用对象。😊

***

## 2. 主要特点

垃圾回收器具有以下主要特点：

- **自动内存管理** &#x20;

  垃圾回收器自动识别和回收无效对象，开发者无需手动释放内存，从而降低内存泄露风险并简化编程模型。
- **分代回收策略** &#x20;

  垃圾回收器通常采用分代回收技术，将堆分为年轻代与老年代，对不同代采用不同的回收算法，从而提高整体回收效率。年轻代中对象大多“朝生暮死”，而老年代则存放长生命周期对象。
- **多种回收算法** &#x20;

  根据不同应用场景，JVM 提供了多种垃圾回收器，如 Serial GC、Parallel GC、CMS GC、G1 GC、ZGC、Shenandoah 等。各收集器在回收时的停顿时间、并发能力、吞吐量等指标上各有侧重。
- **并发与低停顿** &#x20;

  新型垃圾回收器（如 G1 GC、ZGC、Shenandoah）注重并发回收和低停顿设计，能够在应用运行过程中几乎无停顿地完成垃圾回收，适合实时性要求较高的场景。
- **可调控性强** &#x20;

  垃圾回收器支持通过 JVM 参数（如 -XX:ParallelGCThreads、-XX:ConcGCThreads、-XX:MaxGCPauseMillis 等）进行调优，开发者可以根据实际业务场景调整垃圾回收策略，平衡吞吐量和响应时间。

下表对比了几种常见垃圾回收器的主要特点：

| 回收器              | 主要特点                     | 适用场景            |
| ---------------- | ------------------------ | --------------- |
| Serial GC        | 单线程执行，回收过程简单，停顿时间较长      | 小型应用或单核环境       |
| Parallel GC      | 多线程并行执行，适合吞吐量优先，停顿时间中等   | 批处理、大数据量应用      |
| CMS GC           | 并发标记清除，低停顿，可能产生内存碎片      | 响应时间要求较高的系统     |
| G1 GC            | 分区域回收，兼顾吞吐量与低停顿，动态调整回收时机 | 大型多核服务器、延迟敏感型应用 |
| ZGC / Shenandoah | 极低停顿、并发回收，适合超大堆内存场景      | 高并发、超大内存系统      |

这些特点构成了垃圾回收器设计与调优的基础，在面试中常被问及各类垃圾回收器的优劣及选择依据。🚀

***

## 3. 应用目标

掌握垃圾回收器的知识具有如下应用目标：

1. **自动管理内存资源** &#x20;

   通过垃圾回收器自动回收不再使用的对象，保证内存的持续可用，避免内存泄露和溢出问题，降低应用维护难度。
2. **提高系统性能** &#x20;

   合理选择和调优垃圾回收器，可以减少 GC 停顿时间，提高系统响应速度和吞吐量，尤其在高并发场景下至关重要。
3. **平衡吞吐量与响应时间** &#x20;

   不同垃圾回收器在停顿时间与吞吐量之间存在权衡，通过针对业务场景选择合适的收集器并调整 JVM 参数，可以达到最优性能。
4. **辅助系统监控与调优** &#x20;

   通过对垃圾回收器的深入理解，结合 GC 日志和内存监控工具，开发者能及时发现并解决内存问题，进一步指导系统优化。
5. **面试答题支持** &#x20;

   面试中涉及垃圾回收器的理论、算法与实践调优是高频考点，深入掌握相关知识有助于在面试中展现扎实的 JVM 内部机制理解和工程实践能力。📈

***

## 4. 主要内容及其组成部分

垃圾回收器作为垃圾收集与内存分配的重要组成部分，其内容主要包括以下几个方面：

### 4.1 垃圾回收器的分类

垃圾回收器可以从不同维度进行分类，主要包括：

- **按执行模式分** &#x20;
  - **串行回收器（Serial GC）**：单线程执行垃圾回收，适用于小型应用。 &#x20;
  - **并行回收器（Parallel GC）**：利用多线程并行回收，提高回收效率，适合吞吐量优先的场景。 &#x20;
- **按回收策略分** &#x20;
  - **标记-清除/标记-整理**：通过标记存活对象后回收垃圾对象，适合老年代回收。 &#x20;
  - **复制算法**：将存活对象复制到另一块区域，适用于年轻代的高效回收。 &#x20;
- **按停顿要求分** &#x20;
  - **低停顿回收器（如 CMS、G1 GC、ZGC、Shenandoah）**：采用并发或增量回收，最大限度降低停顿时间，适用于实时性要求高的应用。

### 4.2 各类垃圾回收器的组成

每种垃圾回收器不仅在回收算法上有所不同，其内部实现结构也有较大差异。主要包括：

- **Serial GC** &#x20;

  采用单线程、Stop-The-World 模式进行垃圾回收。其主要组成部分包括标记阶段、清除或复制阶段，以及后续的内存整理。由于全部工作由单一线程完成，因此在多核环境下不能充分利用硬件优势，但实现简单。
- **Parallel GC** &#x20;

  利用多线程并行执行回收工作。其内部将垃圾收集任务分解为多个子任务，同时在多个 CPU 核心上并行执行，显著提升了垃圾回收的效率。Parallel GC 适用于 CPU 资源丰富、吞吐量要求较高的应用。
- **CMS GC** &#x20;

  采用并发标记清除（Concurrent Mark-Sweep）技术，尽量减少停顿时间。CMS 分为初始标记、并发标记、重新标记和并发清除几个阶段。其中初始标记和重新标记需要短暂停顿，其余阶段则在应用线程并发执行，适合响应时间敏感的场景。
- **G1 GC** &#x20;

  采用分区（Region）管理堆内存，并通过预测模型决定回收时机。G1 GC 将堆划分为多个相同大小的区域，通过收集部分区域的垃圾来达到整体内存回收目标。G1 GC 的主要组成部分包括初始标记、并发标记、最终标记和混合回收阶段，其核心优势在于能在大堆内存下保持低停顿。

下表对比了几种垃圾回收器的组成和工作模式：

| 回收器         | 执行模式    | 主要组成阶段                    | 优势                |
| ----------- | ------- | ------------------------- | ----------------- |
| Serial GC   | 单线程，STW | 标记 → 清除/复制 → 整理           | 实现简单，适合单核或小堆环境    |
| Parallel GC | 多线程并行   | 并行标记与复制/清除                | 吞吐量高，充分利用多核优势     |
| CMS GC      | 并发标记清除  | 初始标记 → 并发标记 → 重新标记 → 并发清除 | 低停顿，适合实时性要求高的应用   |
| G1 GC       | 分区并行回收  | 初始标记 → 并发标记 → 最终标记 → 混合回收 | 大堆环境下低停顿，具备预测回收优势 |

### 4.3 垃圾回收器的调优参数

针对不同垃圾回收器，JVM 提供了一系列调优参数，主要包括：

- **Parallel GC 调优参数** &#x20;
  - `-XX:ParallelGCThreads`：设置并行 GC 的线程数。 &#x20;
  - `-XX:MaxGCPauseMillis`：指定期望的最大 GC 停顿时间，GC 会根据此目标动态调整。
- **CMS GC 调优参数** &#x20;
  - `-XX:ConcGCThreads`：设置并发 GC 阶段的线程数。 &#x20;
  - `-XX:CMSInitiatingOccupancyFraction`：设置老年代内存占用率达到多少百分比时启动 CMS。
- **G1 GC 调优参数** &#x20;
  - `-XX:MaxGCPauseMillis`：目标最大停顿时间，G1 GC 会尽量满足该目标。 &#x20;
  - `-XX:G1HeapRegionSize`：指定 G1 GC 堆区域的大小，根据应用特性选择合适的区域尺寸。

通过对这些参数的合理调优，可以使垃圾回收器在保证低停顿的前提下，提高整体吞吐量和内存利用率。

***

## 5. 原理剖析

深入解析垃圾回收器的原理，有助于理解其内部工作机制及调优策略。

### 5.1 垃圾回收的基本流程

无论采用哪种垃圾回收器，GC 的基本流程一般包括以下几个步骤：

1. **标记阶段** &#x20;

   从 GC Roots 开始，遍历整个对象图，标记所有可达对象。
2. **清除或整理阶段** &#x20;

   对未被标记的对象进行清除，或者将存活对象整理到一端，以便连续分配。
3. **内存整理与压缩** &#x20;

   在部分收集器中，会对内存进行整理，消除内存碎片，确保内存连续性。

这些阶段在不同垃圾回收器中的实现有所不同。例如，Serial GC 采用单线程完成整个流程；而 CMS GC 则采用并发标记和并发清除以降低停顿时间；G1 GC 通过区域划分实现部分回收与混合回收，动态控制停顿。

### 5.2 并发与低停顿实现

现代垃圾回收器为了满足高并发和低停顿要求，通常会采用并发收集和增量收集技术。例如：

- **CMS GC**：在标记和清除阶段采用并发方式，使大部分垃圾回收工作与应用线程并行执行，从而显著降低 Stop-The-World 时间。
- **G1 GC**：将堆分为多个相同大小的区域，采用预测模型确定各区域的回收时机，并在混合回收过程中并发回收部分区域，既保证内存回收效果，又使停顿时间保持在较低水平。
- **ZGC 和 Shenandoah**：通过低延迟设计，实现了几乎无停顿的垃圾回收，这些收集器通过指针压缩和并发复制技术，降低了 GC 对应用线程的影响。

### 5.3 内存碎片与整理机制

内存碎片问题在标记-清除算法中较为突出，而复制算法和标记-整理算法则能较好地解决此问题。例如，复制算法通过将存活对象复制到新的连续内存区域，从而完全消除了内存碎片。G1 GC 在混合回收时也会对部分区域进行整理，确保内存分配的连续性和高效性。

### 5.4 调优策略与风险控制

调优垃圾回收器主要关注以下几方面：

- 合理设置 JVM 参数（如线程数、停顿时间目标等），使回收时机与应用负载相匹配。
- 利用 GC 日志和监控工具（如 VisualVM、JConsole）实时观察 GC 触发频率和停顿时间，调整参数以降低内存碎片和延长对象存活时间的影响。
- 针对不同业务场景，选择合适的垃圾回收器（例如响应时间敏感的系统可选 CMS 或 G1 GC，批处理系统则可选择 Parallel GC），在实际生产环境中不断验证和优化。

通过对这些原理的深入理解，开发者可以在面试中详细解释各类垃圾回收器的工作机制及其调优方法，从而展现扎实的 JVM 内部原理知识。💡

***

## 6. 应用与拓展

垃圾回收器的应用与扩展在实际开发中具有重要意义，主要体现在以下几个方面：

### 6.1 高性能系统调优

在大规模、高并发应用中，垃圾回收停顿时间直接影响系统响应。通过选择合适的垃圾回收器（如 G1 GC、CMS GC）和调整相关 JVM 参数，可以实现低停顿和高吞吐量的平衡，从而提升用户体验。例如，电商或金融系统常利用 G1 GC 的分区回收机制，实现实时数据处理。

### 6.2 系统监控与故障排查

通过 GC 日志和内存监控工具，开发者可以实时掌握垃圾回收器的工作状态，及时发现因 GC 引起的性能瓶颈或内存泄露问题。掌握垃圾回收器原理后，可以结合内存快照、JMX 数据和 GCViewer 等工具，深入分析系统内存使用情况，迅速定位问题并优化。

### 6.3 案例实践与工程经验

在实际项目中，开发者往往需要针对具体场景选择垃圾回收器并进行调优。例如，在某大型分布式系统中，通过调低 `-XX:CMSInitiatingOccupancyFraction` 参数，提前启动 CMS GC，从而显著降低了 Full GC 停顿时间，提升了系统整体吞吐量。这样的实践经验不仅有助于优化系统，还能在面试中作为实际案例展示技术实力。

### 6.4 新技术趋势

随着 JVM 技术不断演进，新型垃圾回收器（如 ZGC、Shenandoah）正逐步应用于生产环境。它们以低延迟、并发复制为特点，适用于超大堆内存和高实时性需求的场景。关注这些前沿技术，不仅能拓宽技术视野，也能在面试中展现对未来发展趋势的把握。🚀

### 6.5 工程实践与知识分享

在团队内部，通过对垃圾回收器的深入剖析和调优实践，可以形成一套完整的内存管理最佳实践文档，为项目优化和新成员培训提供支持。同时，将这些经验通过技术博客、讲座等形式分享，有助于建立个人技术品牌，并在面试中彰显工程师的全局视野与实践能力。📚

***

## 7. 面试问答

以下提供五个典型面试问答，采用面试者口吻详细回答关于垃圾回收器的常见问题，帮助你在面试中自信从容地回答相关问题。

### 7.1 问题一：请介绍一下 JVM 中常见的垃圾回收器及其主要区别

【回答】： &#x20;

在 JVM 中，常见的垃圾回收器有 Serial GC、Parallel GC、CMS GC 和 G1 GC。Serial GC 采用单线程执行，适用于小堆或单核环境；Parallel GC 利用多线程并行回收，适合吞吐量要求高的场景；CMS GC 采用并发标记和清除，能大幅降低停顿时间，但可能产生内存碎片；G1 GC 则通过将堆划分为多个区域，实现低停顿和高吞吐量的平衡。这些回收器各有优劣，选择时需结合系统负载、响应要求和硬件环境。

### 7.2 问题二：G1 GC 是如何工作的？它的主要优势有哪些？

【回答】： &#x20;

G1 GC 将堆内存划分为多个固定大小的区域，根据对象存活率和回收成本预测各区域的回收收益。在回收过程中，G1 GC 会先进行初始标记，再进行并发标记，最后选择部分区域进行混合回收。其主要优势在于能在大堆内存环境下保持低停顿时间，同时兼顾高吞吐量，通过区域回收减少整体回收压力，是现代大型系统常用的垃圾回收器。

### 7.3 问题三：如何通过 JVM 参数调优垃圾回收器以降低 GC 停顿时间？

【回答】： &#x20;

调优垃圾回收器可以从多个方面入手，比如设置 `-XX:MaxGCPauseMillis` 目标最大停顿时间、合理配置并行 GC 线程数（`-XX:ParallelGCThreads` 和 `-XX:ConcGCThreads`），以及针对 CMS GC 设置 `-XX:CMSInitiatingOccupancyFraction`。这些参数可以帮助 JVM 更早地启动垃圾回收或加快回收速度，从而降低 GC 停顿时间。通过分析 GC 日志，我曾在项目中调整参数，使 Full GC 的停顿时间从数百毫秒降低到几十毫秒，显著提高了系统响应速度。

### 7.4 问题四：在实际应用中，你如何判断选择哪种垃圾回收器更适合？

【回答】： &#x20;

选择垃圾回收器需要结合应用特点：若系统堆内存较小或运行在单核环境中，Serial GC 或 Parallel GC 较为合适；若系统对响应时间要求较高，则应选择 CMS GC 或 G1 GC。通常，我会通过监控工具分析 GC 日志、停顿时间和吞吐量，结合系统负载和业务场景，评估不同回收器的表现，然后进行实际测试和调优，以确定最合适的方案。

### 7.5 问题五：请结合实例说明垃圾回收器调优对系统性能的实际影响

【回答】： &#x20;

在一个高并发电商平台项目中，初期我们使用 Parallel GC，但由于 Full GC 停顿时间较长，导致部分请求响应延迟。通过调整参数（如降低 `-XX:CMSInitiatingHeapOccupancyFraction` 并切换至 CMS GC 或 G1 GC），我们提前触发垃圾回收，并发执行标记清除操作。调优后，GC 停顿时间从平均 300 毫秒降至 50 毫秒左右，系统整体响应时间大幅改善。这一实践不仅验证了调优策略的有效性，也展示了深入理解垃圾回收器对优化系统性能的重要性。

***

## 总结

本文详细解析了 JVM 垃圾收集与内存分配中的“垃圾回收器”部分，从概述与定义、主要特点、应用目标，到主要内容及其组成部分，再到原理剖析、应用与拓展，最后通过面试问答的形式展示了常见问题及详细解答。 &#x20;

全文指出： &#x20;

- 垃圾回收器是 JVM 自动内存管理的关键，能有效回收无用对象，防止内存泄露和溢出。 &#x20;
- 根据执行模式、回收策略及停顿要求，不同垃圾回收器各有优势和适用场景。 &#x20;
- 调优垃圾回收器时，应结合系统监控数据和实际业务需求，通过调整 JVM 参数平衡吞吐量与响应时间。 &#x20;
- 现代回收器如 G1 GC、CMS GC 在低停顿和高并发场景中表现优异，是当前大型系统常用的垃圾回收方案。

通过本文学习，你不仅能够全面掌握垃圾回收器的原理和应用，还能在面试中自信从容地回答相关问题，并在实际开发中不断优化系统性能。希望这篇文章能为你提供充分的理论支持和实践指导，助你在面试和工程实践中取得优异成绩！😊

[a. 串行垃圾回收器](<a. 串行垃圾回收器/a. 串行垃圾回收器.md> "a. 串行垃圾回收器")

[b. 并行垃圾回收器](<b. 并行垃圾回收器/b. 并行垃圾回收器.md> "b. 并行垃圾回收器")

[c. CMS(并发)垃圾收集器](<c. CMS(并发)垃圾收集器/c. CMS(并发)垃圾收集器.md> "c. CMS(并发)垃圾收集器")

[d. G1垃圾收集器](<d. G1垃圾收集器/d. G1垃圾收集器.md> "d. G1垃圾收集器")

[e. ZGC](<e. ZGC/e. ZGC.md> "e. ZGC")
